var _ = require("lodash");

var TestDataUtility = require("../../../testtools/testDataUtility").TestDataUtility;
var messageCode = require("../../../../lib/xs/util/message").Code;
var MockstarFacade = require("../../../testtools/mockstar_facade").MockstarFacade;
var testdata = require("../../../testdata/testdata").data;

if (jasmine.plcTestRunParameters.mode === 'all') {
	describe("p_item_account_determination", function() {

		var mockstar = null;

		var sSessionId = "sSessionId";
		var iCvId = 1;
		var sControllingAreaId = "CA1";
		var dTwoDaysAgo = rewindDate(new Date(), 2);
		var dThreeDaysAgo = rewindDate(new Date, 3);

		function invokeProcedure(oInput) {
			var aItems = oInput.aItems;
			var sessionId = oInput.sSessionId || sSessionId;
			var cvId = oInput.iCvId || iCvId;
			var controllingAreaId = oInput.sControllingAreaId || sControllingAreaId;
			var masterdataTimestamp = oInput.dMasterdataTimestamp || new Date();
			var sReevaluate = oInput.bReevaluate !== undefined ? oInput.bReevaluate : false;

			return mockstar.call(aItems, sessionId, cvId, controllingAreaId, masterdataTimestamp, sReevaluate, null, null);
		}

		beforeOnce(function() {
			mockstar = new MockstarFacade({
				testmodel: "sap.plc.db.calculationmanager.procedures/p_item_account_determination",
				substituteTables: {
					item_temporary: {
						name: "sap.plc.db::basis.t_item_temporary"
					},
					material: {
						name: "sap.plc.db::basis.t_material"
					},
					material_account_determination: {
						name: "sap.plc.db::basis.t_material_account_determination"
					},
					activity_type: {
						name: "sap.plc.db::basis.t_activity_type"
					},
					process: {
						name: "sap.plc.db::basis.t_process"
					}
				}
			});
		});

		afterOnce(function() {
			mockstar.cleanup("sap.plc.db.calculationmanager.procedures");
			mockstar.cleanup(testdata.testPackage);
		});

		function checkAccounts(oResult, mItemId2AccountId) {
			var numberOfItems = _.keys(mItemId2AccountId).length;
			var oDeterminedAccounts = oResult[0];
			var oMessages = oResult[1];

			var resultSize = oDeterminedAccounts.length;
			jasmine.log(`Checking result size: needs to be ${numberOfItems} and is ${resultSize}`);
			expect(resultSize).toEqual(numberOfItems);

			var sExpectedMessageCode = messageCode.ACCOUNTDETERMINATION_ACCOUNT_SET_INFO.code;

			_.each(oDeterminedAccounts, function(obj, iIndex) {
				const iItemId = obj.ITEM_ID;
				var bIsItemExpectedInResult = _.has(mItemId2AccountId, iItemId);
				jasmine.log(`Checking if item ${iItemId} is expected in result: needs to be true and is ${bIsItemExpectedInResult.toString()}`);
				expect(bIsItemExpectedInResult).toBe(true);

				var sExpectedAccountId = mItemId2AccountId[iItemId];
				var sActualAccountId = obj.ACCOUNT_ID;
				jasmine.log(`Checking account for item ${iItemId}: needs to be ${sExpectedAccountId} and is ${sActualAccountId}`);
				expect(sActualAccountId).toBe(sExpectedAccountId);

				// check if for the current item an account was determined the correct message id is generated by the procedure
				var aMsgIndiciesForItem = _.map(oMessages, function(obj, iIndex) {
					if (obj.ITEM_ID === iItemId) {
						return iIndex;
					}
				});

				var bMessageForCurrentItemFound = true;
				_.each(aMsgIndiciesForItem, function(value, iIndex) {
					if(oMessages[iIndex].MSG_ID !== sExpectedMessageCode) {
						bMessageForCurrentItemFound = false;
						return false;
					}
				});

				jasmine.log(`Checking if for item ${iItemId} a success message was generated: expected message code ${sExpectedMessageCode} and ${bMessageForCurrentItemFound ? "is" : "is NOT"} found`);
				expect(bMessageForCurrentItemFound).toBe(true);
			});
		}

		function rewindDate(oDate, iDays) {
			oDate.setDate(oDate.getDate() - iDays);
			return oDate;
		}

		function runDbModificationTests(oTestItem, oModifiedPropertiesInDb, mExpectedAccounts, bReevaluate) {
			// arrange
			bReevaluate = bReevaluate || false; // set optional parameter to false if not defined
			var oDbItem = _.extend({}, oTestItem, {
				SESSION_ID: sSessionId,
				CALCULATION_VERSION_ID: iCvId,
				IS_ACTIVE: 1,
				IS_DELETED: 0,
				IS_DIRTY: 0,
				CHILD_ITEM_CATEGORY_ID: oTestItem.ITEM_CATEGORY_ID,
			}, oModifiedPropertiesInDb);
			mockstar.insertTableData("item_temporary", oDbItem);

			// act
			var result = invokeProcedure({
				aItems: [oTestItem],
				bReevaluate: bReevaluate
			});

			// assert
			checkAccounts(result, mExpectedAccounts);
		}

		describe("general tests", function() {

			var oItem = {
				ITEM_ID: 1,
				ITEM_CATEGORY_ID: 9,
				MATERIAL_ID: null,
				MATERIAL_TYPE_ID: null, 
				VALUATION_CLASS_ID: null,
				PLANT_ID: null,
				ACTIVITY_TYPE_ID: null,
				PROCESS_ID: null,
				IS_DISABLING_ACCOUNT_DETERMINATION: 0
			};

			it("should reset account (=null) if the category of the item was to a account determination unrelated category (TextItem)", function() {
				// act + assert
				runDbModificationTests(oItem, {
					ITEM_CATEGORY_ID: 1
				}, {
					1: null
				});
			});

			it("should not reset account (=null) if the item has a modified property (except item category)", function() {
				// act + assert
				runDbModificationTests(oItem, {
					ITEM_DESCRIPTION: "description"
				}, {});
			});
		});

		describe("material account determination", function() {

			beforeEach(function() {
				mockstar.clearAllTables();
			});

			var items = {
				ITEM_ID: [1, 2, 3, 4],
				ITEM_CATEGORY_ID: [1, 2, 4, 6],
				MATERIAL_ID: ["P-100", "P-100", "P-300", "P-400"],
				MATERIAL_TYPE_ID: ["RAW", "RAW", "SEM", null],
				VALUATION_CLASS_ID: ["HIGH", "LOW", "HIGH", null],
				PLANT_ID: ["1000", "2000", "1000", null],
				ACTIVITY_TYPE_ID: [null, null, null, null],
				PROCESS_ID: [null, null, null, null],
				IS_DISABLING_ACCOUNT_DETERMINATION: [0, 0, 0, 0]
			};

			var defaultMaterialAccountsDetermination = {
				CONTROLLING_AREA_ID: [sControllingAreaId],
				MATERIAL_TYPE_ID: ["RAW"],
				PLANT_ID: ["1000"],
				VALUATION_CLASS_ID: ["HIGH"],
				ACCOUNT_ID: ["100000"],
				_VALID_FROM: [testdata.oYesterday.toJSON()]
			};

			it("should not run account determination if no material_id is set", function() {
				// arrange
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);
				var oItemWithOutMaterialId = {
					ITEM_ID: 1,
					ITEM_CATEGORY_ID: 1,
					MATERIAL_ID: null,
					MATERIAL_TYPE_ID: null,
					VALUATION_CLASS_ID: null,
					PLANT_ID: "1000",
					ACTIVITY_TYPE_ID: null,
					PROCESS_ID: null,
					IS_DISABLING_ACCOUNT_DETERMINATION: 0
				};

				// act
				var result = invokeProcedure({
					aItems: [oItemWithOutMaterialId]
				});

				// assert
				checkAccounts(result, {});
			});

			it("should reset accounts if accounts defined for different controling area (null is returned as account id)", function() {
				// arrange
				// the account determination for the given items shall be executed, since these are new items (with modified plant_id and material_id)
				// (difference to tests which ensure to not run account det; see below); if the account det is run and no accounts are found (other controling
				// 	area), the account info shall be set to input
				var materialAccountsDetermination = {
					CONTROLLING_AREA_ID: ["#CA2", "#CA2"],
					MATERIAL_TYPE_ID: ["RAW", "RAW"],
					PLANT_ID: ["1000", "2000"],
					VALUATION_CLASS_ID: ["", ""],
					ACCOUNT_ID: ["100000", "100000"],
					_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
				};
				mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

				// act
				var result = invokeProcedure({
					aItems: new TestDataUtility(items).getObjects()
				});

				// assert
				checkAccounts(result, {
				});
			});

			it("should run account determination if material_id of the item was changed", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {
					MATERIAL_ID: "something different"
				}, {
					1: "100000"
				});
			});

			it("should run account determination if material_id of the item was changed and return null if material_id is valid in masterdata", function() {
			    var oMaterialTestData = {
			        "MATERIAL_ID" : ['MAT1', 'MAT1', 'MAT1'],
            		"IS_PHANTOM_MATERIAL" : [1, 0, 1],
                    "IS_CONFIGURABLE_MATERIAL" : [1, 0, 1],
                    "MATERIAL_TYPE_ID" : ["MT1", "MT1", "MT1"],
					"MATERIAL_GROUP_ID" : ["MG1", "MG1", "MG1"],
            		"_VALID_FROM" : ['2015-06-06T15:40:09.691Z', '2013-01-01T15:39:09.691Z', '2014-06-06T15:40:00.691Z'],
            		"_VALID_TO" : [null, '2014-06-06T15:39:09.691Z','2015-06-06T15:39:09.691Z'],
            		"_SOURCE" : [1, 1, 1]
				}
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);
				mockstar.insertTableData("material", oMaterialTestData);
				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.MATERIAL_ID = "MAT1";
				oTestItem.MATERIAL_TYPE_ID = "MT1";
				runDbModificationTests(oTestItem, {
					MATERIAL_ID: "MAT2"
				}, {
					1: null
				});
			});
			
			it("should run account determination if material_type_id of the item was changed", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {
					MATERIAL_TYPE_ID: "XYZ"
				}, {
					1: defaultMaterialAccountsDetermination.ACCOUNT_ID[0]
				});
			});
			
			it("should not run account determination if material_type_id of the item was changed and IS_DISABLING_ACCOUNT_DETERMINATION = 1", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				let oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.IS_DISABLING_ACCOUNT_DETERMINATION = 1;
				runDbModificationTests(oTestItem, {
					MATERIAL_TYPE_ID: "XYZ"
				}, {});
			});

			it("should run account determination if valuation_class_id of the item was changed", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {
					VALUATION_CLASS_ID: "XYZ"
				}, {
					1: defaultMaterialAccountsDetermination.ACCOUNT_ID[0]
				});
			});

			it("should not run account determination if valuation_class_id of the item was changed but IS_DISABLING_ACCOUNT_DETERMINATION = 1", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.IS_DISABLING_ACCOUNT_DETERMINATION = 1;
				runDbModificationTests(oTestItem, {
					VALUATION_CLASS_ID: "XYZ"
				}, {});
			});

			it("should run account determination if plant_id of the item was changed", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {
					PLANT_ID: "1337"
				}, {
					1: defaultMaterialAccountsDetermination.ACCOUNT_ID[0]
				});
			});
			
			it("should run account determination for an item if plant_id is set to null", function() {
				// arrange
				// plant_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.PLANT_ID = null;

				// act + assert
				runDbModificationTests(oTestItem, {
					PLANT_ID: "1000"
				}, {
				});
			});
			
			it("should run account determination for an item if material_type_id is set to null", function() {
				// arrange
				// material_type_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.MATERIAL_TYPE_ID = null;

				// act + assert
				runDbModificationTests(oTestItem, {
					MATERIAL_TYPE_ID: "RAW"
				}, {
				});
			});

			it("should run account determination for an item if valuation_class_id is set to null", function() {
				// arrange
				// valuation_class_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.VALUATION_CLASS_ID = null;

				// act + assert
				runDbModificationTests(oTestItem, {
					// no account rule defined for valuation_class_id = null; account must be reset
					VALUATION_CLASS_ID: "VC1"
				}, {
				});
			});

			it("should not run account determination for an item if neither material_id, material_type_id, valuation_class_id nor plant_id was changed and iv_reevaluate = false", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {
					ITEM_DESCRIPTION: "blub"
				}, {});
			});
			
			it("should run account determination for an item where neither material_id, material_type_id, valuation_class_id nor plant_id are unchanged and iv_reevaluate = true", function() {
				// the iv_reevaluate parameter of the procedure defines if the procedure shall run the account determination only for items with changes 
				// (on material_id, plant_id see above); if it set to true the account determination shall run for all of the input items; this is applied 
				// for the set masterdata timestamp scenario, where nothing is changed on the items but the accounts need to be re-determined 
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {}, {
					1: defaultMaterialAccountsDetermination.ACCOUNT_ID[0]
				}, true); // bReevaluate = true
			});
			
			it("should not run account determination for an item if plant_id is null and unchanged (iv_reevaluate = false)", function() {
				// arrange
				// plant_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.PLANT_ID = null;

				// act + assert
				runDbModificationTests(oTestItem, {}, {});
			});

			it("should not run account determination for an item if material_id is null and unchanged (iv_reevaluate = false)", function() {
				// arrange
				// material_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.MATERIAL_ID = null;

				// act + assert
				runDbModificationTests(oTestItem, {}, {});
			});

			it("should not run account determination for an item if material_type_id is null and unchanged (iv_reevaluate = false)", function() {
				// arrange
				// material_type_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.MATERIAL_TYPE_ID = null;

				// act + assert
				runDbModificationTests(oTestItem, {}, {});
			});

			it("should run account determination for an item if material_type_id is null and unchanged (iv_reevaluate = false) and is_disabling_account_determination has changed", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {IS_DISABLING_ACCOUNT_DETERMINATION: 1}, {
					1: defaultMaterialAccountsDetermination.ACCOUNT_ID[0]
				}); 
			});

			it("should not run account determination for an item if valuation_class_id is null and unchanged (iv_reevaluate = false)", function() {
				// arrange
				// valuation_class_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.VALUATION_CLASS_ID = null;

				// act + assert
				runDbModificationTests(oTestItem, {}, {});
			});
			
			it("should reset account information if material_id was changed and no account can be found for combination of material_type_id, valuation_class_id and plant_id", function() {
				mockstar.insertTableData("material_account_determination", defaultMaterialAccountsDetermination);
				var oTestItem = {
					ITEM_ID: 1,
					ITEM_CATEGORY_ID: 1,
					MATERIAL_ID: "100", // change of material trigger the determination
					MATERIAL_TYPE_ID: null,
					VALUATION_CLASS_ID: null,
					PLANT_ID: "1000",
					ACTIVITY_TYPE_ID: null,
					PROCESS_ID: null,
					IS_DISABLING_ACCOUNT_DETERMINATION: 0
				};

				runDbModificationTests(oTestItem, {
					PLANT_ID: "1337",
					ACCOUNT_ID: defaultMaterialAccountsDetermination.ACCOUNT_ID[0]
				}, {
				});
			});

			describe("no valuation class defined", function() {

				beforeEach(function() {
					mockstar.clearTable("material_account_determination");
				});
				
				// construct new procedure input based on the general input data; set the valuation_class_id for all items (use the map function of
				var noValuationClassItems = new TestDataUtility(items).extend({
					VALUATION_CLASS_ID: items.ITEM_ID.map(function() {
						return null;
					})
				}).build();

				it("should select account 100000 for item 1 if account defined for plant 1000 and material type raw", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: ["RAW"],
						PLANT_ID: ["1000"],
						VALUATION_CLASS_ID: [""],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(noValuationClassItems).getObjects()
					});

					// assert
					checkAccounts(result, {
						1: materialAccountsDetermination.ACCOUNT_ID[0]
					});
				});

				it("should select account 100000 for item 3 if account defined for material type sem and plant 1000", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: ["SEM"],
						PLANT_ID: ["1000"],
						VALUATION_CLASS_ID: [""],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(noValuationClassItems).getObjects()
					});

					// assert
					checkAccounts(result, {
						3: materialAccountsDetermination.ACCOUNT_ID[0]
					});
				});

				it("should select account 100000 for item 4 if account defined only for controlling area", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: [""],
						PLANT_ID: [""],
						VALUATION_CLASS_ID: [""],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(noValuationClassItems).getObjects()
					});

					// assert
					checkAccounts(result, {
						4: materialAccountsDetermination.ACCOUNT_ID[0]
					});
				});

			});

			describe("valuation class defined", function() {

				beforeEach(function() {
					mockstar.clearAllTables();
				});

				it("should select account 100000 for item 1 and 200000 for item 2 if " +
					"valuation class HIGH/LOW are defined for plant 1000/2000 and mat P-100/P-200",
					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
							MATERIAL_TYPE_ID: ["RAW", "RAW"],
							PLANT_ID: ["1000", "2000"],
							VALUATION_CLASS_ID: ["HIGH", "LOW"],
							ACCOUNT_ID: ["100000", "200000"],
							_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

						// act
						var result = invokeProcedure({
							aItems: new TestDataUtility(items).getObjects()
						});

						// assert
						checkAccounts(result, {
							1: materialAccountsDetermination.ACCOUNT_ID[0],
							2: materialAccountsDetermination.ACCOUNT_ID[1]
						});
					});

				it("should select account 100000 for item 3 if valuation class HIGH is defined for P-300 and plant 1000", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: ["SEM"],
						PLANT_ID: ["1000"],
						VALUATION_CLASS_ID: ["HIGH"],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(items).getObjects()
					});

					// assert
					checkAccounts(result, {
						3: materialAccountsDetermination.ACCOUNT_ID[0]
					});
				});

				it("should select account 100000 for item 3 but 200000 for additional items (no valuation class defined for mat type" +
					"and plant 2000) if valuation class HIGH is defined P - 300 and plant 1000, but additional item with same material from plant 2000 added",

					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
							MATERIAL_TYPE_ID: ["SEM", "SEM"],
							PLANT_ID: ["1000", "2000"],
							VALUATION_CLASS_ID: ["HIGH", ""],
							ACCOUNT_ID: ["100000", "200000"],
							_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);
						var iCategory = items.ITEM_CATEGORY_ID[2];
						var sMaterialId = items.MATERIAL_ID[2];

						var aItemsWithAdditionalItemInPlant1000 = new TestDataUtility(items).addObject({
							ITEM_ID: 100,
							ITEM_CATEGORY_ID: iCategory,
							MATERIAL_ID: sMaterialId,
							MATERIAL_TYPE_ID: "SEM",
							VALUATION_CLASS_ID: null,
							PLANT_ID: "2000",
							ACTIVITY_TYPE_ID: null,
							PROCESS_ID: null,
							IS_DISABLING_ACCOUNT_DETERMINATION: 0
						}).getObjects();

						// act
						var result = invokeProcedure({
							aItems: aItemsWithAdditionalItemInPlant1000
						});

						// assert
						checkAccounts(result, {
							3: materialAccountsDetermination.ACCOUNT_ID[0],
							100: materialAccountsDetermination.ACCOUNT_ID[1]
						});
					});
			});

			describe("account determination with wild cards", function() {

				beforeEach(function() {
					mockstar.clearTable("material_account_determination");
				});

				it("should select account 100000 for item 1 and 3 if account with wild card for material type; plant 1000", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: ["*"],
						PLANT_ID: ["1000"],
						VALUATION_CLASS_ID: ["HIGH"],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(items).getObjects()
					});

					// assert
					checkAccounts(result, {
						1: materialAccountsDetermination.ACCOUNT_ID[0],
						3: materialAccountsDetermination.ACCOUNT_ID[0]
					});
				});

				it("should select account 100000 for item 1 and 2 if account with wild card for plant and valuation class; material type RAW", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: ["RAW"],
						PLANT_ID: ["*"],
						VALUATION_CLASS_ID: ["*"],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(items).getObjects()
					});

					// assert
					checkAccounts(result, {
						1: materialAccountsDetermination.ACCOUNT_ID[0],
						2: materialAccountsDetermination.ACCOUNT_ID[0]
					});
				});

				it("should reset account (account=null) if account with wild card for plant; material type RAW; wrong valuation class",
					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId],
							MATERIAL_TYPE_ID: ["RAW"],
							PLANT_ID: ["*"],
							VALUATION_CLASS_ID: [""], // means no valuation class defined
							ACCOUNT_ID: ["100000"],
							_VALID_FROM: [testdata.oYesterday.toJSON()]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

						// act
						var result = invokeProcedure({
							aItems: new TestDataUtility(items).getObjects()
						});

						// assert
						checkAccounts(result, {
						});
					});

				it("should run account determination for temporary materials when a matching rule is available", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: ["RAW"],
						PLANT_ID: ["*"],
						VALUATION_CLASS_ID: ["HIGH"],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);
					var oItemTempMaterial = _.extend({}, new TestDataUtility(items).getObject(0), {
						MATERIAL_ID: "TEMP"
					});

					// act
					var result = invokeProcedure({
						aItems: [oItemTempMaterial]
					});

					// assert
					checkAccounts(result, {
						1: "100000"
					});
				});

				it("should select account 100000 for item 1, 2, 3 (all materials) if account defined for entire controlling area (wildcard for plant, material type)", function() {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId],
						MATERIAL_TYPE_ID: ["*"],
						PLANT_ID: ["*"],
						VALUATION_CLASS_ID: ["*"],
						ACCOUNT_ID: ["100000"],
						_VALID_FROM: [testdata.oYesterday.toJSON()]
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(items).getObjects()
					});

					// assert
					checkAccounts(result, {
						1: materialAccountsDetermination.ACCOUNT_ID[0],
						2: materialAccountsDetermination.ACCOUNT_ID[0],
						3: materialAccountsDetermination.ACCOUNT_ID[0],
						4: materialAccountsDetermination.ACCOUNT_ID[0]
					});
				});

				it("should select account 400000 for item 1 (most specific rule), 200000 for item 3 (rule most specific for this item) and 100000 for all other items",
					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId, sControllingAreaId, sControllingAreaId],
							PLANT_ID: ["*", "*", "*", "1000"],
							MATERIAL_TYPE_ID: ["*", "*", "RAW", "RAW"],
							VALUATION_CLASS_ID: ["*", "HIGH", "HIGH", "HIGH"],
							ACCOUNT_ID: ["100000", "200000", "300000", "400000"],
							_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON(),
								testdata.oYesterday.toJSON()
							]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);
						// act
						var result = invokeProcedure({
							aItems: new TestDataUtility(items).getObjects()
						});

						// assert
						checkAccounts(result, {
							1: materialAccountsDetermination.ACCOUNT_ID[3],
							2: materialAccountsDetermination.ACCOUNT_ID[0],
							3: materialAccountsDetermination.ACCOUNT_ID[1],
							4: materialAccountsDetermination.ACCOUNT_ID[0]
						});
					});

				it("should select account 100000 for item 1 (rule for material type wins) if one row defines wild card for plant_id and one for " +
					"material_type_id; all other columns identical",
					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
							PLANT_ID: ["*", "1000"],
							MATERIAL_TYPE_ID: ["RAW", "*"],
							VALUATION_CLASS_ID: ["HIGH", ""],
							ACCOUNT_ID: ["100000", "200000"],
							_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

						// act
						var result = invokeProcedure({
							aItems: new TestDataUtility(items).getObjects()
						});

						// assert
						checkAccounts(result, {
							1: materialAccountsDetermination.ACCOUNT_ID[0]
						});
					});

				it("should select account 100000 for item 1 and 3 (vc has highest weight); account 200000 for item 2 (match of mt rule) if one rule only for " +
					"valuation_class_id defined; 2 other rules defined for material_type and plant_id",
					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
							PLANT_ID: ["*", "*", "1000"],
							MATERIAL_TYPE_ID: ["*", "RAW", "*"],
							VALUATION_CLASS_ID: ["HIGH", "*", "*"],
							ACCOUNT_ID: ["100000", "200000", "300000"],
							_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

						// act
						var result = invokeProcedure({
							aItems: new TestDataUtility(items).getObjects()
						});

						// assert
						checkAccounts(result, {
							1: materialAccountsDetermination.ACCOUNT_ID[0],
							2: materialAccountsDetermination.ACCOUNT_ID[1],
							3: materialAccountsDetermination.ACCOUNT_ID[0]
						});
					});

				it("should select account 200000 for item 1 (match type + plant more specific as vc wildcard) if one rule only valuation_class_id defined;" +
					"select account 100000 for item 3 (due to the vc match)",
					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
							PLANT_ID: ["*", "1000"],
							MATERIAL_TYPE_ID: ["*", "RAW"],
							VALUATION_CLASS_ID: ["HIGH", "*"],
							ACCOUNT_ID: ["100000", "200000"],
							_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

						// act
						var result = invokeProcedure({
							aItems: new TestDataUtility(items).getObjects()
						});

						// assert
						checkAccounts(result, {
							1: materialAccountsDetermination.ACCOUNT_ID[1],
							3: materialAccountsDetermination.ACCOUNT_ID[0]
						});
					});

				it("should not crash (account selection irrelevant but, 100000 for item 1) if two rules point to the same account",
					function() {
						// arrange
						var materialAccountsDetermination = {
							CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
							PLANT_ID: ["1000", "1000"],
							MATERIAL_TYPE_ID: ["RAW", "RAW"],
							VALUATION_CLASS_ID: ["HIGH", "*"],
							ACCOUNT_ID: ["100000", "100000"],
							_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
						};
						mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

						// act
						var result = invokeProcedure({
							aItems: new TestDataUtility(items).getObjects()
						});

						// assert
						checkAccounts(result, {
							1: materialAccountsDetermination.ACCOUNT_ID[1]
						});
					});
			});

			describe("account determination and considering the masterdata timestamp", function() {

				beforeEach(function() {
					mockstar.clearAllTables();
				});

				var singleItem = {
					ITEM_ID: 1,
					ITEM_CATEGORY_ID: 1,
					MATERIAL_ID: "P-100",
					MATERIAL_TYPE_ID: null,
					VALUATION_CLASS_ID: null,
					PLANT_ID: "1000",
					ACTIVITY_TYPE_ID: null,
					PROCESS_ID: null,
					IS_DISABLING_ACCOUNT_DETERMINATION: 0
				};
				
				function doMaterialAccountDeterminationTableTest(oMdDate, oExpectedAccounts) {
					// arrange
					var materialAccountsDetermination = {
						CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
						PLANT_ID: ["1000", "1000"],
						MATERIAL_TYPE_ID: ["*", "*"],
						VALUATION_CLASS_ID: ["*", "*"],
						ACCOUNT_ID: ["100000", "200000"],
						_VALID_FROM: [dThreeDaysAgo.toJSON(), testdata.oYesterday.toJSON()],
						_VALID_TO: [testdata.oYesterday.toJSON(), null],
					};
					mockstar.insertTableData("material_account_determination", materialAccountsDetermination);

					// act
					var result = invokeProcedure({
						aItems: [singleItem],
						dMasterdataTimestamp: oMdDate
					});

					// assert
					checkAccounts(result, oExpectedAccounts);
				}

				it(
					"t_material_account_determination: should select account 200000 for item 1, since it's the current account if valuation class changed from HIGH to LOW",
					function() {
						doMaterialAccountDeterminationTableTest(new Date(), {
							1: "200000"
						});
					});

				it("t_material_account_determination: should select account 100000 for item 1, since it is the old if use a master data timestamp from 2 days ago",
					function() {
						doMaterialAccountDeterminationTableTest(dTwoDaysAgo, {
							1: "100000"
						});
					});
			});

		});
		describe("internal activity account determination", function() {

			beforeEach(function() {
				mockstar.clearAllTables();
			});

			var items = {
				ITEM_ID: [1, 2, 3, 4],
				ITEM_CATEGORY_ID: [3, 3, 3, 3],
				MATERIAL_ID: [null, null, null, null],
				MATERIAL_TYPE_ID: [null, null, null, null],
				VALUATION_CLASS_ID: [null, null, null, null],
				PLANT_ID: [null, null, null, null],
				ACTIVITY_TYPE_ID: ["AC1", "AC2", "???", null],
				PROCESS_ID: [null, null, null, null],
				IS_DISABLING_ACCOUNT_DETERMINATION: [0, 0, 0, 0]
			};

			var activityTypes = {
				ACTIVITY_TYPE_ID: ["AC1", "AC2", "AC1"],
				CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId, "#CA2"],
				ACCOUNT_ID: ["100000", "200000", "900000"],
				_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
			}

			var md_activityTypes = {
				ACTIVITY_TYPE_ID: ["AC1", "AC1"],
				CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId, ],
				ACCOUNT_ID: ["100000", "200000"],
				_VALID_FROM: [dThreeDaysAgo.toJSON(), testdata.oYesterday.toJSON()],
				_VALID_TO: [testdata.oYesterday.toJSON(), null],
			}

			it("should set ACCOUNT_ID of item to null if ACCOUNT_ID in t_activity_type is null", function() {
				// arrange
				var oActivityTypeData = {
					ACTIVITY_TYPE_ID: ["AC1"],
					CONTROLLING_AREA_ID: [sControllingAreaId],
					ACCOUNT_ID: [null],
					_VALID_FROM: [testdata.oYesterday.toJSON()]
				};
				mockstar.clearTable("activity_type");
				mockstar.insertTableData("activity_type", oActivityTypeData);

				// act
				var result = invokeProcedure({
					aItems: new TestDataUtility(items).getObjects()
				});

				// assert
				checkAccounts(result, {
					1: null
				});

			});

			it("should not run account determination if activity_type_id is unchanged and iv_reevaluate = false", function() {
				mockstar.insertTableData("activity_type", activityTypes);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {}, {});
			});

			it("should not run account determination if activity_type_id is null but unchanged and iv_reevaluate = false", function() {
				// activity_type_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				// this test is checking this
				mockstar.insertTableData("activity_type", activityTypes);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.ACTIVITY_TYPE_ID = null;
				runDbModificationTests(oTestItem, {}, {});
			});

			it("should run account determination if activity_type_id is unchanged, iv_reevaluate = false and is_disabling_account_determination is changed", function() {
				mockstar.insertTableData("activity_type", activityTypes);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {IS_DISABLING_ACCOUNT_DETERMINATION: 1}, {
					1: activityTypes.ACCOUNT_ID[0]
				}, true); // bReevaluate = true
			});

			it("should run account determination if activity_type_id is unchanged and iv_reevaluate = true", function() {
				// the iv_reevaluate parameter of the procedure defines if the procedure shall run the account determination only for items with changes 
				// (on material_id, plant_id see above); if it set to true the account determination is ran for all of the input items; this is applied 
				// for the set masterdata timestamp scenario, where nothing is changed on the items but the accounts need to be re-determined 
				mockstar.insertTableData("activity_type", activityTypes);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {}, {
					1: activityTypes.ACCOUNT_ID[0]
				}, true); // bReevaluate = true
			});

			it("should only determine accounts for valid interal activity ids (item 1,2)",
				function() {
					// arrange
					mockstar.insertTableData("activity_type", activityTypes);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(items).getObjects()
					});

					// assert
					checkAccounts(result, {
						1: activityTypes.ACCOUNT_ID[0],
						2: activityTypes.ACCOUNT_ID[1]
					});
				});

				it("should not determine accounts for valid internal activity ids for item 1 and 2 because IS_DISABLING_ACCOUNT_DETERMINATION = 1)",
				function() {
					// arrange
					mockstar.insertTableData("activity_type", activityTypes);
					let oItems = new TestDataUtility(items).getObjects();
					oItems[1].IS_DISABLING_ACCOUNT_DETERMINATION = 1.
					oItems[0].IS_DISABLING_ACCOUNT_DETERMINATION = 1.
					// act
					const result = invokeProcedure({
						aItems: oItems
					});

					// assert
					checkAccounts(result, {});
				});

				it("should not determine accounts for valid internal activity ids for item 1 because IS_DISABLING_ACCOUNT_DETERMINATION = 1  but for item 2 it will run account determination",
				function() {
					// arrange
					mockstar.insertTableData("activity_type", activityTypes);
					let oItems = new TestDataUtility(items).getObjects();
					oItems[1].IS_DISABLING_ACCOUNT_DETERMINATION = 0.
					oItems[0].IS_DISABLING_ACCOUNT_DETERMINATION = 1.
					// act
					const result = invokeProcedure({
						aItems: oItems
					});

					// assert
					checkAccounts(result, {2: activityTypes.ACCOUNT_ID[1]});
				});

			it("should ignore items from irrelevant categories and determine accounts for relevant items (item 1,2)",
				function() {
					// arrange
					var oItemsWithUnrelatedCategoryBuilder = new TestDataUtility(items).addObject({
						ITEM_ID: 100,
						ITEM_CATEGORY_ID: 8,
						MATERIAL_ID: null,
						MATERIAL_TYPE_ID: null,
						VALUATION_CLASS_ID: null,
						PLANT_ID: null,
						ACTIVITY_TYPE_ID: "AC1",
						PROCESS_ID: null,
						IS_DISABLING_ACCOUNT_DETERMINATION: 0
					});
					mockstar.insertTableData("activity_type", activityTypes);

					// act
					var result = invokeProcedure({
						aItems: oItemsWithUnrelatedCategoryBuilder.getObjects()
					});

					// assert
					checkAccounts(result, {
						1: activityTypes.ACCOUNT_ID[0],
						2: activityTypes.ACCOUNT_ID[1]
					});
				});

			it("should select account 200000 for item 1, since it's the current account if master data timestamp: account has changed",
				function() {
					// arrange
					mockstar.insertTableData("activity_type", md_activityTypes);
					var firstItem = new TestDataUtility(items).getObject(0);

					// act
					var result = invokeProcedure({
						aItems: [firstItem]
					});

					// assert
					checkAccounts(result, {
						1: "200000"
					});
				});

				it("should not select account 200000 for item 1, since it's the current account if master data timestamp: account has changed but IS_DISABLING_ACCOUNT_DETERMINATION = 1",
				function() {
					// arrange
					mockstar.insertTableData("activity_type", md_activityTypes);
					let firstItem = new TestDataUtility(items).getObject(0);
					firstItem.IS_DISABLING_ACCOUNT_DETERMINATION = 1;

					// act
					const result = invokeProcedure({
						aItems: [firstItem]
					});

					// assert
					checkAccounts(result, {});
				});

			it("should select account 100000 for item 1, since it was the account then if master data timestamp has changed (timestamp is from 2 days ago)",
				function() {
					// arrange
					mockstar.insertTableData("activity_type", md_activityTypes);
					var firstItem = new TestDataUtility(items).getObject(0);

					// act
					var result = invokeProcedure({
						aItems: [firstItem],
						dMasterdataTimestamp: dTwoDaysAgo
					});

					// assert
					checkAccounts(result, {
						1: "100000"
					});
				});
		});

		describe("process account determination", function() {

			beforeEach(function() {
				mockstar.clearAllTables();
			});

			var items = {
				ITEM_ID: [1, 2, 3, 4],
				ITEM_CATEGORY_ID: [5, 5, 5, 5],
				MATERIAL_ID: [null, null, null, null],
				MATERIAL_TYPE_ID: [null, null, null, null],
				VALUATION_CLASS_ID: [null, null, null, null],
				PLANT_ID: [null, null, null, null],
				ACTIVITY_TYPE_ID: [null, null, null, null],
				PROCESS_ID: ["BP1", "BP2", "???", null],
				IS_DISABLING_ACCOUNT_DETERMINATION: [0, 0, 0, 0]
			};

			var processes = {
				PROCESS_ID: ["BP1", "BP2", "BP1"],
				CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId, "#CA2"],
				ACCOUNT_ID: ["100000", "200000", "900000"],
				_VALID_FROM: [testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON(), testdata.oYesterday.toJSON()]
			};

			var md_processes = {
				PROCESS_ID: ["BP1", "BP1"],
				CONTROLLING_AREA_ID: [sControllingAreaId, sControllingAreaId],
				ACCOUNT_ID: ["100000", "200000"],
				_VALID_FROM: [dThreeDaysAgo.toJSON(), testdata.oYesterday.toJSON()],
				_VALID_TO: [testdata.oYesterday.toJSON(), null],
			};

			it("should set ACCOUNT_ID of item to null if ACCOUNT_ID in t_process is null", function() {
				// arrange
				var oProcessData = {
					PROCESS_ID: ["BP1"],
					CONTROLLING_AREA_ID: [sControllingAreaId],
					ACCOUNT_ID: [null],
					_VALID_FROM: [testdata.oYesterday.toJSON()]
				};
				var firstItem = new TestDataUtility(items).getObject(0);
				mockstar.clearTable("process");
				mockstar.insertTableData("process", oProcessData);

				// act
				var result = invokeProcedure({
					aItems: [firstItem]
				});

				// assert
				checkAccounts(result, {
					1: null
				});
			});

			it("should not run account determination if process_id is unchanged and iv_reevaluate = false", function() {
				mockstar.insertTableData("process", processes);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {}, {});
			});

			it("should run account determination if process_id is unchanged, iv_reevaluate = false and is_disabling_account_determination is changed", function() {
				mockstar.insertTableData("process", processes);
			
				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {IS_DISABLING_ACCOUNT_DETERMINATION: 1}, {1: processes.ACCOUNT_ID[0]});
			});

			it("should not run account determination if process_id is null but unchanged and iv_reevaluate = false", function() {
				// process_id is nullable column; comparision in SQL need some special treatment; the logic should also handle NULL values correctly
				// this test is checking this
				mockstar.insertTableData("process", processes);

				var oTestItem = new TestDataUtility(items).getObject(0);
				oTestItem.PROCESS_ID = null;
				runDbModificationTests(oTestItem, {}, {});
			});

			it("should run account determination if process_id is unchanged  iv_reevaluate = true", function() {
				// the iv_reevaluate parameter of the procedure defines if the procedure shall run the account determination only for items with changes 
				// (on material_id, plant_id see above); if it set to true the account determination is ran for all of the input items; this is applied 
				// for the set masterdata timestamp scenario, where nothing is changed on the items but the accounts need to be re-determined 
				mockstar.insertTableData("process", processes);

				var oTestItem = new TestDataUtility(items).getObject(0);
				runDbModificationTests(oTestItem, {}, {
					1: processes.ACCOUNT_ID[0]
				}, true); // bReevaluate = true
			});

			it("should only determine accounts for valid process ids (item 1,2)",
				function() {
					// arrange
					mockstar.insertTableData("process", processes);

					// act
					var result = invokeProcedure({
						aItems: new TestDataUtility(items).getObjects()
					});

					// assert
					checkAccounts(result, {
						1: processes.ACCOUNT_ID[0],
						2: processes.ACCOUNT_ID[1]
					});
				});

				it("should not determine accounts for valid process ids item 1 and 2 because IS_DISABLING_ACCOUNT_DETERMINATION=1",
				function() {
					// arrange
					mockstar.insertTableData("process", processes);
					let oItems = new TestDataUtility(items).getObjects();
					oItems[0].IS_DISABLING_ACCOUNT_DETERMINATION = 1;
					oItems[1].IS_DISABLING_ACCOUNT_DETERMINATION = 1;

					// act
					const result = invokeProcedure({
						aItems: oItems
					});

					// assert
					checkAccounts(result, {});
				});

				it("should not determine accounts for valid process ids item 2 because IS_DISABLING_ACCOUNT_DETERMINATION=1 but for item 1 the account determination should be done",
				function() {
					// arrange
					mockstar.insertTableData("process", processes);
					let oItems = new TestDataUtility(items).getObjects();
					oItems[0].IS_DISABLING_ACCOUNT_DETERMINATION = 0;
					oItems[1].IS_DISABLING_ACCOUNT_DETERMINATION = 1;

					// act
					const result = invokeProcedure({
						aItems: oItems
					});

					// assert
					checkAccounts(result, {1: processes.ACCOUNT_ID[0]});
				});

			it("should ignore items from irrelevant categories and determineaccounts for relevant items", function() {
				// arrange
				var oItemsWithUnrelatedCategoryBuilder = new TestDataUtility(items).addObject({
					ITEM_ID: 100,
					ITEM_CATEGORY_ID: 8,
					MATERIAL_ID: null,
					MATERIAL_TYPE_ID: null,
					VALUATION_CLASS_ID: null,
					PLANT_ID: null,
					ACTIVITY_TYPE_ID: null,
					PROCESS_ID: "BP1",
					IS_DISABLING_ACCOUNT_DETERMINATION: 0
				});
				mockstar.insertTableData("process", processes);

				// act
				var result = invokeProcedure({
					aItems: oItemsWithUnrelatedCategoryBuilder.getObjects()
				});

				// assert
				checkAccounts(result, {
					1: processes.ACCOUNT_ID[0],
					2: processes.ACCOUNT_ID[1]
				});
			});

			it("should select account 200000 for item 1 (is the current account) after masterdata timestamp change", function() {
				// arrange
				mockstar.insertTableData("process", md_processes);
				var firstItem = new TestDataUtility(items).getObject(0);

				// act
				var result = invokeProcedure({
					aItems: [firstItem]
				});

				// assert
				checkAccounts(result, {
					1: "200000"
				});
			});

			it("should not select account 200000 for item 1 (is the current account) after masterdata timestamp change but IS_DISABLING_ACCOUNT_DETERMINATION = 1", function() {
				// arrange
				mockstar.insertTableData("process", md_processes);
				let firstItem = new TestDataUtility(items).getObject(0);
				firstItem.IS_DISABLING_ACCOUNT_DETERMINATION = 1;
				// act
				const result = invokeProcedure({
					aItems: [firstItem]
				});

				// assert
				checkAccounts(result, {});
			});

			it("master data timestamp: should account account 100000 for item 1 sicne timestamp is from 2 days ago", function() {
				// arrange
				mockstar.insertTableData("process", md_processes);
				var firstItem = new TestDataUtility(items).getObject(0);

				// act
				var result = invokeProcedure({
					aItems: [firstItem],
					dMasterdataTimestamp: dTwoDaysAgo
				});

				// assert
				checkAccounts(result, {
					1: "100000"
				});
			});

		});
	}).addTags(["All_Unit_Tests"]);
}